import Foundation
import AVFoundation
import ExpoModulesCore

public class ExpoAudioStreamModule: Module {
  private var player = AVQueuePlayer() // Use AVQueuePlayer to handle streaming and queue management
  private var chunksReceivedCount = 0
  private var chunksDownloadedCount = 0
  private var isCancelled = false

  public func definition() -> ModuleDefinition {
    Name("ExpoAudioStream")

    Events("onStatusUpdate")

    // Adds a new asynchronous function for streaming audio
    AsyncFunction("playStreamFromURL") { (urlString: String, headers: [String: String], body: String, promise: Promise) in
      Task {
        do {
          try await self.streamAudio(from: urlString, withBody: Data(body.utf8), headers: headers, promise: promise)
        } catch {
          self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "error", "message": "Failed to play stream"])
          promise.reject("STREAM_ERROR", "Failed to play stream")
        }
      }
    }
    AsyncFunction("stopPlayback") { (promise: Promise) in
        self.stopPlayback(promise: promise)
    }
  }

  // Adapted function to handle streaming
  private func streamAudio(from urlString: String, withBody body: Data, headers: [String: String], promise: Promise) async throws {
    self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "start"])
    resetState()
    // Configure AVAudioSession for playback
    do {
        try AVAudioSession.sharedInstance().setCategory(.playback, mode: .default, options: [.mixWithOthers])
        try AVAudioSession.sharedInstance().setActive(true)
    } catch {
        print("Failed to configure AVAudioSession: \(error)")
        self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "error", "message": "Failed to configure AVAudioSession: \(error)"])
        return
    }
    
    guard let url = URL(string: urlString) else { 
      self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "error", "message": "Invalid URL"])
      throw URLError(.badURL)
      }
    
    var request = URLRequest(url: url)
    request.httpMethod = "POST"
    headers.forEach { key, value in
      request.setValue(value, forHTTPHeaderField: key)
    }
    request.httpBody = body
    
    self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "loading"])

    let (asyncBytes, _) = try await URLSession.shared.bytes(for: request)
    if #available(iOS 15.0, *) {
        var accumulatedData = Data()
        let desiredDataSizeForOneSecond = 24 * 1024 // 24 KB in bytes, for 192 kbps

        var itemsToPlayCount = 0
        var itemsPlayedCount = 0

        for try await chunk in asyncBytes {
          if self.isCancelled {
            self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "cancelled 1"])
            promise.resolve()  // Resolve the promise when cancelled
            return
          }
          accumulatedData.append(chunk)
          // Process the accumulatedData after it approximates one second of audio
          if accumulatedData.count >= desiredDataSizeForOneSecond {
              itemsToPlayCount += 1
              if (!self.isCancelled) {
                let tempFileURL = writeDataToTemporaryFile(accumulatedData)
                queueAndPlay(tempFileURL) {
                  itemsPlayedCount += 1
                  if itemsPlayedCount == itemsToPlayCount {
                    self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "done"])
                    DispatchQueue.main.async {
                      promise.resolve()
                      do {
                        try AVAudioSession.sharedInstance().setActive(false)
                      } catch {
                        print("Failed to deactivate AVAudioSession: \(error)")
                      }
                    }
                  }
                }
              }
              accumulatedData.removeAll() // Reset for the next accumulation
          }
        }
        if !accumulatedData.isEmpty {
          itemsToPlayCount += 1
          let tempFileURL = writeDataToTemporaryFile(accumulatedData)
          queueAndPlay(tempFileURL) {
            itemsPlayedCount += 1
            if itemsPlayedCount == itemsToPlayCount {
              self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "done"])
              DispatchQueue.main.async {
                promise.resolve()
                do {
                  try AVAudioSession.sharedInstance().setActive(false)
                } catch {
                  print("Failed to deactivate AVAudioSession: \(error)")
                }
              }
            }
          }
        }
    } else {
        self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "error", "message": "iOS version not supported for async streaming."])
        // Fallback on earlier versions or handle the unsupported version
        print("iOS version not supported for async streaming.")
    }
  }

  // Function to queue and play audio chunks
  private func queueAndPlay(_ fileURL: URL, completion: @escaping () -> Void) {
    DispatchQueue.main.async { [weak self] in
      guard let self = self else { return }
      let playerItem = AVPlayerItem(url: fileURL)
      NotificationCenter.default.addObserver(forName: .AVPlayerItemDidPlayToEndTime, object: playerItem, queue: .main) { [weak self] _ in
        guard let strongSelf = self else { return }
        completion() // Call the completion closure when the item finishes playing
        // Remove the temporary file
        do {
          try FileManager.default.removeItem(at: fileURL)
          self?.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "chunkRemoved"])
        } catch {
          self?.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "error", "message": "Failed to remove temporary file"])
        }
        NotificationCenter.default.removeObserver(strongSelf, name: .AVPlayerItemDidPlayToEndTime, object: playerItem)
      }
      self.player.insert(playerItem, after: nil)
      
      if self.player.rate == 0 {
        self.player.play()
      }
    }
  }


  // Helper function to write data to a temporary file, adapted from the original
  private func writeDataToTemporaryFile(_ data: Data) -> URL {
    let tempFileURL = URL(fileURLWithPath: NSTemporaryDirectory()).appendingPathComponent(UUID().uuidString + ".mp3")
    do {
      try data.write(to: tempFileURL)
      chunksDownloadedCount += 1
      self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "chunkDownloaded", "count": chunksDownloadedCount])
    } catch {
      print("Error writing chunk to file: \(error)")
    }
    return tempFileURL
  }

  private func resetState() {
    chunksReceivedCount = 0
    chunksDownloadedCount = 0
    // Consider stopping the player and removing all items from the queue
    isCancelled = false  // Reset the cancellation flag
    player.removeAllItems()
    // Deactivate the AVAudioSession
    do {
        try AVAudioSession.sharedInstance().setActive(false, options: .notifyOthersOnDeactivation)
    } catch {
        print("Failed to deactivate AVAudioSession: \(error)")
    }

    self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "reset"])
  }

  private func stopPlayback(promise: Promise) {
    DispatchQueue.main.async { [weak self] in
      guard let self = self else { 
        promise.reject("PLAYER_ERROR", "Player instance is nil")
        return
      }
      self.isCancelled = true  // Set the cancellation flag to true
      self.player.pause()  // Stop the playback
      self.player.removeAllItems()  // Clear all items from the queue
      
      // Ensure no more processing takes place
      self.appContext?.eventEmitter?.sendEvent(withName: "onStatusUpdate", body: ["status": "stopped"])
      promise.resolve()  // Resolve the promise to signal that the operation is fully stopped
    }
  }
}
